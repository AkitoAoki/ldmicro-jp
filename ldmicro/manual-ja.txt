
概要
============

LDmicroはラダー図からPIC16やAtmel AVRのネイティブコードを生成するツールです。
マイコンの制御ソフトウェアは通常アセンブラやC、BASICなどのプログラミング言語で書かれます。これは命令文を並べることで動作を定義します。これは機械語命令を順番に実行するというマイクロプロセッサ内部の仕組みをそのまま反映したものといえます。

一方、PLC(プログラマブルロジックコントローラ)はラダー・ロジックというものを使ってプログラムされます。例えば、単純なプログラムは次のようなものです。

   ||                                                                    ||
   ||    Xbutton1           Tdon           Rchatter           Yred       ||
 1 ||-------]/[---------[TON 1.000 s]-+-------]/[--------------( )-------||
   ||                                 |                                  ||
   ||    Xbutton2           Tdof      |                                  ||
   ||-------]/[---------[TOF 2.000 s]-+                                  ||
   ||                                                                    ||
   ||                                                                    ||
   ||                                                                    ||
   ||    Rchatter            Ton             Tnew           Rchatter     ||
 2 ||-------]/[---------[TON 1.000 s]----[TOF 1.000 s]---------( )-------||
   ||                                                                    ||
   ||                                                                    ||
   ||                                                                    ||
   ||------[END]---------------------------------------------------------||
   ||                                                                    ||
   ||                                                                    ||

TON は Turn-ON delay (遅延立ち上がり)、TOF は Turn-OFf delay (遅延立ち下がり)を意味します。
--] [-- は入力を表し、回路の接点(スイッチ)のように働きます。
--( )-- は出力を表し、回路のコイルのように働きます。
ラダーロジックの詳しい説明は他のWeb上のページなどにゆずります。
命令の詳細はこのマニュアルで後述します。

見た目に明らかな違いは次のようなものです。

    * プログラムはテキストではなく箱を線でつないだような図として表します。
      多くの人はこちらの方が理解しやすいと感じます。

    * プログラムがスイッチ(入力)とコイル(出力)だけの単純なものなら
      そのまま回路図のように読めます。
      デジタル回路の知識がある方は直感的に感じるでしょう。

    * いつ、どこを計算するかはラダー図のコンパイラが判断します。
      変数を再計算するタイミングに頭を悩ませる必要はありませんし、
      計算の順番で悩むこともありません。PLCを処理するツールが
      考えてくれます。

LDmicroはPIC16やAtmel AVRのプログラムを生成することができます。
現在以下のプロセッサに対応しています。

    * PIC16F877
    * PIC16F628
    * PIC16F876 (untested)
    * PIC16F88 (untested)
    * PIC16F819 (untested)
    * PIC16F887 (untested)
    * PIC16F886 (untested)
    * ATmega128
    * ATmega64
    * ATmega162 (untested)
    * ATmega32 (untested)
    * ATmega16 (untested)
    * ATmega8 (untested)

対応プロセッサを増やすのは簡単ですが、私にはテストする環境がありません。
特に対応してほしいものがあればご相談ください。

LDmicroではラダー図でプログラムを書くことができます。また、ロジックをPC上でシミュレートして試すことができます。それでうまく動くことが確認できたら、入出力ピンを割り当ててマイコン用にコンパイルします。出力のHEXファイルはそのままマイコンに書き込むことができます。

LDmicroは一般的なPLCプログラミング環境になるべく似せてあります。いくつか例外はありますが、商用のものでもどのみちまったく規格が共通なわけではありません。よく知っていると思う場合でも、各命令の説明を熟読してください。この文書は読者にラダー・ロジックやPLCの基本的な知識があることを前提としています (入力-計算-出力のサイクルなど)。

追加のターゲット
==================

コンパイラはANSI Cのコードを出力することもできます。Cコンパイラに対応したプロセッサであればこれを使ってプログラムできますが、ランタイムをユーザが用意する必要があります。具体的には、LDmicroは PlcCycle() という関数のコードを生成します。これを外部から毎サイクル呼ぶ必要があります。また、PlcCycle() の使う入出力の部分も実装する必要があります。詳しくは生成コードのコメントをご覧ください。

また、LDmicroはプロセッサ非依存のバイトコードを生成することができます。
これはラダー・ロジックを実行するための仮想マシン(VM)を対象とするもので、実行用のインタプリタのサンプルを同梱しています。これはポータブルなC言語で書かれています。VMをユーザが実装する限り、これはどのようなマシンでも動くはずです。用途としては、ラダー・ロジックを一種のスクリプト言語として大きなプログラム中に組み込んで使うことが考えられます。詳しくはサンプルのインタプリタのコメントをご覧ください。

コマンドラインオプション
====================

ldmicro.exe は通常オプションなしで起動されます。つまり、通常は単にショートカットなどからダブルクリックで起動して、GUIで操作します。

ファイル名を指定して起動した場合 ("ldmicro.exe asd.ld" など) は、LDmicroはそのファイルを読み込んで立ち上がります。ファイルが読み込めない場合はエラーを表示します。.ld拡張子をLDmicroに関連付けするとラダー図のファイルをダブルクリックするだけで開けるので便利です。

"ldmicro.exe /c src.ld dest.hex" のように引数を与えて起動すると、src.ld をコンパイルして dest.hex に結果を書き出します。成功したかどうかにかかわらず、LDmicroはコンパイル後そのまま終了します。メッセージはコンソールに出力されます。このモードはコマンドラインから実行することを想定しています。

基本
======

LDmicroをダブルクリックで起動すると、空のプログラムが表示されます。
ファイルを与えて起動するとそのファイルを読み込んで起動します。
LDmicroのプログラムの保存形式(.LD)は独自のもので、他の形式からインポートする機能はありません。

初期状態は、空のラングがひとつあるだけのプログラムです。ここに命令を追加することができます。例えば、メニューの[命令]->[挿入: 接点]を選ぶと Xnew という名前の接点が追加されます。命令の挿入する位置はカーソルで指定します。左右に挿入すると直列に、上下に挿入すると並列になります。
XnewのXというのは、その接点がマイコンの入力ピンに割り当てられるという意味です。入出力接点は実際のピンに割り当てる前にマイコンの種類を選んで名前をつける必要があります。ピンを割り当てるには、画面下部の変数一覧表からダブルクリックします。
Xの他にも色々な頭文字があり種類を表しています。例えば：

    * X -- マイコンの入力ピン
    * Y -- マイコンの出力ピン
    * R -- 内部リレー。1ビットの内部メモリ
    * T -- タイマー。遅延立ち上がり、遅延立ち下がり、保持遅延の3種
    * C -- カウンター。上昇、下降、循環の3種
    * A -- AD変換器から読みだした数値
    * 頭文字なし -- 汎用のメモリ上の数値変数

追加した時には "name" の部分は "new" になっています。何のための変数なのかわかりやすいように名前をつけてください。リレーの命令をダブルクリックするか、カーソルを合わせてリターンを押すと編集できます。
プログラム中で同じ名前の変数は常に同じものを指します。例えば、TON (遅延立ち上がりタイマ) に Tdelay という名前をつけたら、他の所にある TOF (遅延立ち下がりタイマ) に Tdelay という名前をつけることはできません。
一方、RTO (保持遅延タイマ)に Tdelay と名前をつけてから RES (タイマリセット) 命令で Tdelay を指定しても問題ありません。この場合は対象のタイマは同じものだからです。

変数名はアルファベット、数字、下線 (_) を使うことができます。頭文字に数字を使うことはできません。また、大文字と小文字は区別されます。XDogとXdOgは別の変数です。

変数一般の命令 (MOV, ADD, EQU など) はどの種類の変数に対しても働きます。つまり、タイマーやカウンタを計算に使うことができるということです。これは例えば、カウンタの値がある範囲内にあるかどうかを調べるために使えます。

全ての変数は16ビット符号付き整数です。値の範囲は -32768 から 32767 です。値は10進数 (0, 1234, -56) で指定できるほか、ASCIIコード ('A', 'z') を指定することもできます。その場合はシングルクォート (') で文字を括って下さい。

画面下部にはプログラム中の変数の一覧表が表示されます。この表はプログラムから自動的に作られます。ほとんどの変数は設定することはありませんが、頭文字が X (入力ピン), Y (出力ピン), A (AD変換値) のものはマイコンのピン番号を割り当てる必要があります。ダブルクリックするとピンの設定が開きます。

プログラムの編集は、ラダー図に命令を挿入したり削除することで行います。プログラム画面で点滅しているカーソルは、今選択している命令と、命令の挿入される位置を示しています。カーソルが望む場所にない場合は、<Tab>を押して切り替えるか、マウスで命令を選んで下さい。そこで<Delete>を押すと命令を削除できます。ダブルクリックや<Enter>を押すと命令の設定ができます。

命令を挿入するときは、カーソルの棒の出方で挿入される位置が変わります。命令の左右に挿入すると直列に、命令の上下に挿入すると並列になります。この上下左右の指定は矢印キーで切り替えます。命令の挿入位置にはいくつかルールがあります。例えば、コイルの右に命令を置くことはできません。

プログラムを新規作成した時には、空のラングがひとつだけあります。メニューの[編集]→[ラングを挿入]で新しいラングを上下に挿入できます。理論的には、命令を全て並列に配置することで巨大なラングが一つあるだけのプログラムを作ることができます。しかし、論理的な単位ごとにラングを分けて作るほうが後々作業しやすいでしょう。

プログラムが完成したら、シミュレータでテストすることができます。また、マイコンに書き込むためのHEXファイルにコンパイルすることができます。

シミュレータ
==========

シミュレーションモードに入るには、メニューの[シミュレータ]→[シミュレーションモード]を選ぶか、<Ctrl+M>を押します。再度押すとシミュレーションモードを抜けます。

シミュレーションモードではプログラムの表示の仕方が変わります。カーソルが消え、通電している命令は赤くハイライトされます。そうでない命令はグレーになります。<Space>を押すとシミュレーションを1サイクル進めます。

リアルタイムシミュレーションを行うには、メニューの[シミュレータ]→[リアルタイムシミュレーション開始]を選ぶか、<Ctrl+R>を押します。このモードではSpaceキーを押し続けるようにサイクルが自動で進んでゆきます。プログラムの状態が変わると即座に反映されます。

画面下部の変数一覧表から、プログラムの入力状態を確認できます。項目をダブルクリックすると、入力を切り替えることができます。これはラダー図中の命令をダブルクリックすることでも行えます。リアルタイムの場合は入力の変化は即座に反映されます。そうでない場合は<Space>を押してサイクルを進めると反映します。

ネイティブコードへのコンパイル
========================

どのようなプログラムでも、結局は.hexファイルにしてマイコンに書き込むためにあります。コンパイルするには、まず対象のマイコンを選びます。これはメニューの[設定]→[ターゲットマイコン]から行います。その後、全ての接点 (頭文字Xの変数)、コイル (頭文字Yの変数)、アナログ変換 (頭文字Aの変数)にマイコンの入出力ポートを割り当てる必要があります。これは画面下部の変数一覧からダブルクリックして行います。変数を選ぶとピンの一覧が表示されるので、その中から選択します。

他の設定としては、サイクル時間(周期)とマイコンの動作周波数があります。これらはメニューの[設定]→[マイコン設定]で調整します。ほとんどの場合サイクル時間を10msから変更する必要はありません。動作周波数の欄にはマイコンとともに使う発振子(水晶やセラミック)の周波数を記入して下さい。

これらの設定が終わればコンパイルできます。メニューで[コンパイル]→[コンパイル]を選びます。[名前をつけてコンパイル]を選ぶとコンパイル結果の出力先を変更できます。コンパイルエラーがなければIntel IHEX形式で機械語を書き出します。できあがったHEXファイルをお使いのライターでチップに書き込んで下さい。

動作させる際は、チップの動作設定(ヒューズとも呼ばれます)に注意して下さい。
PIC16では設定ワードとしてHEXファイルに含めてあるので、ライターが認識して設定します。
AVRではHEXファイルには含まず、ツールを使って設定します。

命令リファレンス
======================

> CONTACT, NORMALLY OPEN        Xname           Rname          Yname
                             ----] [----     ----] [----    ----] [----
  接点 (通常), 常開接点, a接点, メイク接点

    この命令に0を入力すると、0を出力します。
    この命令に1を入力すると、
    関連付けられた入出力ピンや内部リレーが1のとき、1を出力します。
    この命令に1を入力すると、
    関連付けられた入出力ピンや内部リレーが0のとき、0を出力します。
    
    つまり、関連付けられた入出力ピンや内部リレーと同じ信号を出力します。
    この命令を使って入出力ピンや内部リレーの値を調べることができます。
    通常閉じていて、押すと回路が閉じるスイッチに例えられます。


> CONTACT, NORMALLY CLOSED      Xname           Rname          Yname
                             ----]/[----     ----]/[----    ----]/[----
  接点 (反転), 常閉接点, b接点, ブレイク接点

    この命令に0を入力すると、1を出力します。
    この命令に1を入力すると、
    関連付けられた入出力ピンや内部リレーが1のとき、0を出力します。
    この命令に1を入力すると、
    関連付けられた入出力ピンや内部リレーが0のとき、1を出力します。
    
    つまり、関連付けられた入出力ピンや内部リレーと逆の信号を出力します。
    これは開接点と逆の動作です。
    この命令を使って入出力ピンや内部リレーの値を調べることができます。
    通常閉じていて、押すと回路が開くスイッチに例えられます。


> COIL, NORMAL                  Rname           Yname
                             ----( )----     ----( )----
  コイル (通常), 通常コイル

    この命令に0を入力すると、
    関連付けられた出力ピンや内部リレーを0にセットします。
    この命令に1を入力すると、
    関連付けられた出力ピンや内部リレーを1にリセットします。
    
    つまり、関連付けられた出力ピンや内部リレーに信号と同じ値を設定します。

    この命令はラングの右端にしか配置できません。


> COIL, NEGATED                 Rname           Yname
                             ----(/)----     ----(/)----
  コイル (反転), 反転コイル

    この命令に0を入力すると、
    関連付けられた出力ピンや内部リレーを1にセットします。
    この命令に1を入力すると、
    関連付けられた出力ピンや内部リレーを0にリセットします。
    
    つまり、関連付けられた出力ピンや内部リレーに信号と逆の値を設定します。

    この命令はラングの右端にしか配置できません。


> COIL, SET-ONLY                Rname           Yname
                             ----(S)----     ----(S)----
  コイル (セットのみ), セットコイル

    この命令に0を入力すると、なにもしません。
    この命令に1を入力すると、
    関連付けられた出力ピンや内部リレーを1にセットします。
    
    このコイルによって状態が0にリセットされることはありません。
    多くの場合、リセットコイルと組み合わせて使われます。

    この命令はラングの右端にしか配置できません。


> COIL, RESET-ONLY              Rname           Yname
                             ----(R)----     ----(R)----
  コイル (セットのみ), リセットコイル

    この命令に0を入力すると、なにもしません。
    この命令に1を入力すると、
    関連付けられた出力ピンや内部リレーを0にリセットします。
    
    このコイルによって状態が1にセットされることはありません。
    多くの場合、セットコイルと組み合わせて使われます。

    この命令はラングの右端にしか配置できません。


> TURN-ON DELAY                 Tdon
                           -[TON 1.000 s]-
  オンタイマー, オンディレイタイマー, 限時動作即時復帰メイク接点

    この命令は状態を持ち、出力を保持します。
    この命令に1を1秒間入力し続けると、1を出力しはじめます。
    この命令に0を入力すると、すぐに0を出力しはじめます。
    
    秒数はダイアログで調節できます。
    
    この命令は頭文字が T の変数に関連付けられます。
    値はタイマーのカウント値です。
    1が入力された秒数をサイクル時間を単位として数えます。
    この命令はカウント値が設定された秒数以上になると1を出力します。
    カウント値は0が入力される限り0にリセットされ続けます。
    
    変数の値はMOV命令などで他のところから変更することができます。


> TURN-OFF DELAY                Tdoff 
                           -[TOF 1.000 s]-
  オフタイマー, オフディレイタイマー, 限時動作即時復帰ブレイク接点

    この命令は状態を持ち、出力を保持します。
    この命令に0を1秒間入力し続けると、0を出力しはじめます。
    この命令に1を入力すると、すぐに1を出力しはじめます。
    
    秒数はダイアログで調節できます。
    
    この命令は頭文字が T の変数に関連付けられます。
    値はタイマーのカウント値です。
    0が入力された秒数をサイクル時間を単位として数えます。
    この命令はカウント値が設定された秒数以上になると0を出力します。
    カウント値は1が入力される限り0にリセットされ続けます。
    
    変数の値はMOV命令などで他のところから変更することができます。


> RETENTIVE TIMER               Trto  
                           -[RTO 1.000 s]-
  積算タイマー, 積算オンタイマー

    この命令は1を入力された秒数を数えます。
    それまでに通算で1秒間以上1が入力されていれば1を出力します。
    
    入力する1秒間は連続している必要はありません。
    例えば、0.6秒1を入力して、2.0秒0を入力して、0.4秒1を入力すると
    この命令は1を出力しはじめます。
    
    一度1を出力し始めると、この命令は入力が0になっても1を出力し続けます。
    カウントをリセットするには、RESET命令を使います。
    
    この命令は頭文字が T の変数に関連付けられます。
    値はタイマーのカウント値です。
    1が入力された積算の秒数をサイクル時間を単位として数えます。
    この命令はカウント値が設定された秒数以上になると1を出力します。
    
    変数の値はMOV命令やRESET命令などで他のところから変更することができます。


> RESET                        Trto             Citems
                           ----{RES}----     ----{RES}----
  リセット, カウンタリセット, タイマーリセット

    この命令に0を入力すると、なにもしません。
    この命令に1を入力すると、
    関連付けられたタイマやカウンタのカウント値を0にリセットします。
    
    TONとTOFは入力によってリセットするため、この命令は必要ありません。
    RTOやCTU/CTDは単独ではリセットされないので、この命令と
    組み合わせる必要があります。

    この命令はラングの右端にしか配置できません。


> ONE-SHOT RISING                  _
                           --[OSR_/ ]--
  立ち上がり微分, ワンショット立ち上がり

    直前のサイクルでの入力が0で、
    現在のサイクルでの入力が1のときに限り、1を出力します。
    それ以外の場合は0を出力します。
    
    入力の立ち上がりを検知してパルス信号を出力します。
    イベントの通知や処理を行うきっかけなどに有用です。


> ONE-SHOT FALLING               _
                           --[OSF \\_]--
  立ち下がり微分, ワンショット立ち下がり

    直前のサイクルでの入力が1で、
    現在のサイクルでの入力が0のときに限り、1を出力します。
    それ以外の場合は0を出力します。
    
    入力の立ち下がりを検知してパルス信号を出力します。
    イベントの通知や処理を行うきっかけなどに有用です。


> SHORT CIRCUIT, OPEN CIRCUIT
                           ----+----+----      ----+     +----
  閉回路/開回路, 短絡/開放, ショート/オープン

    閉回路の出力は常に入力と同じになります。
    開回路の出力は入力に関わらず常に0です。
    デバッグの際に有用です。


> MASTER CONTROL RELAY
                           -{MASTER RLY}-
  マスターコントロールリレー, マスター制御リレー

    全ラングへの入力信号を表します。
    プログラムの動作中は通常、全てのラングの入力は常に1です。
    この命令に0が入力されると、全てのラングの入力が0になります。
    その状態は再度この命令に1が入力されるまで続きます。
    
    多くの場合、この命令はペアで使われます。
    (おそらく条件付きで)全体をオフにするものと、
    それから復帰するためのものです。


> MOVE                      {destvar :=  }      {Tret :=     }
                           -{ 123     MOV}-    -{ srcvar  MOV}-
  代入, ムーブ

    この命令に0を入力すると、なにもしません。
    この命令に1を入力すると、代入先の変数に代入元の変数の値を設定します。
    
    代入先にはすべての種類の変数が指定できます。
    これにはタイマー変数 (頭文字T)とカウンター変数 (頭文字C)も含みます。
    例えば0を代入するようにすれば、RESET命令と同様の動作になります。
    
    この命令はラングの右端にしか配置できません。


> ARITHMETIC OPERATION       {ADD  kay  :=}       {SUB  Ccnt :=}
                            -{ 'a' + 10   }-     -{ Ccnt - 10  }-

>                            {MUL  dest :=}       {DIV  dv :=  }
                            -{ var * -990 }-     -{ dv / -10000}-
  四則演算 (加減乗除)

    この命令に0を入力すると、なにもしません。
    この命令に1を入力すると、代入先の変数に計算結果を代入します。
    1を入力し続ける限り、計算と代入を毎サイクル繰り返し行います。
    
    右辺の項には変数か数値を指定します。
    数値は10進数 (0, 1234, -56) で指定できるほか、
    ASCIIコード ('A', 'z') を指定することもできます。
    その場合はシングルクォート (') で文字を括って下さい。    

    計算は16ビット符号付き整数で行われます。
    値の範囲は -32768 から 32767 です。
    
    繰り返しに注意して下さい。例えば、a = a + 100という命令を
    ラングに置いたとすると、変数aの値は毎サイクル100ずつ
    上がっていきます。
    計算のステップとして1を単に足したいだけの場合は、OSR/OSFなどと
    条件を組み合わせて、計算と代入が1度しか実行されないようにしてください。
    
    割り算は端数を切り落とします。8 / 3 = 2になります。
    
    この命令はラングの右端にしか配置できません。


> COMPARE               [var ==]        [var >]        [1 >=]
                       -[ var2 ]-      -[ 1   ]-      -[ Ton]-

>                       [var /=]       [-4 <   ]       [1 <=]
                       -[ var2 ]-     -[ vartwo]-     -[ Cup]-
  比較 (等値, 非等値, 超過, 未満, 以上, 以下)

    この命令に0を入力すると、なにもしません。
    この命令に1を入力すると、
    設定された不等式が真である時1を、偽であるとき0を出力します。
    
    この命令は数値や変数の比較に使えます。

    計算は16ビット符号付き整数で行われます。
    値の範囲は -32768 から 32767 です。

    数値は10進数 (0, 1234, -56) で指定できるほか、
    ASCIIコード ('A', 'z') を指定することもできます。
    その場合はシングルクォート (') で文字を括って下さい。    

> COUNTER                      Cname          Cname
                           --[CTU >=5]--  --[CTD >=5]--
  カウンター (アップカウンター, ダウンカウンター)

    これらの命令に0を入力すると、なにもしません。
    これらの命令に1を入力すると、
    直前のサイクルでの入力が0のときに限り、カウントを変化させます。
    アップカウンタはカウント値をインクリメント(1足す)します。
    ダウンカウンタはカウント値をデクリメント(1引く)します。
    カウント値が5以上なら1、そうでなければ0を出力します。
    比較する数値はダイアログで調整できます。
    
    信号の立ち上がりを検知して数値を1ずつ上げ下げする命令です。
    
    これらの命令は頭文字が C の変数に関連付けられます。
    値はカウント値です。
    変数の値はRESET命令やMOV命令などで他のところから変更することができます。
    また、同じ変数に対してCTUとCTDの両方を配置することができます。
    これによって、変数を上げ下げすることができます。

> CIRCULAR COUNTER             Cname
                           --{CTC 0:7}--
  循環カウンタ

    これらの命令に0を入力すると、なにもしません。
    これらの命令に1を入力すると、
    直前のサイクルでの入力が0のときに限り、
    カウント値をインクリメント(1足す)します。
    ただしカウンタ値が7の場合は、インクリメントする代わりに0にリセットします。
    最大値はダイアログで調整できます。
    
    たとえば最大値が7の場合、パルスを送るたびカウンタの値は
      0, 1, 2, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7, 0, 2,....
    のようになります。
    
    順繰りに数値が繰り返すので、シーケンサのように使うことができます。
    
    この命令はラングの右端にしか配置できません。


> SHIFT REGISTER            {SHIFT REG   }
                           -{ reg0..3    }-
  シフトレジスタ

    A shift register is associated with a set of variables. For example,
    this shift register is associated with the variables `reg0', `reg1',
    `reg2', and `reg3'. The input to the shift register is `reg0'. On
    every rising edge of the rung-in condition, the shift register will
    shift right. That means that it assigns `reg3 := reg2', `reg2 :=
    reg1'. and `reg1 := reg0'. `reg0' is left unchanged. A large shift
    register can easily consume a lot of memory. This instruction must
    be the rightmost instruction in its rung.


> LOOK-UP TABLE             {dest :=     }
                           -{ LUT[i]     }-

    A look-up table is an ordered set of n values. When the rung-in
    condition is true, the integer variable `dest' is set equal to the
    entry in the lookup table corresponding to the integer variable
    `i'. The index starts from zero, so `i' must be between 0 and
    (n-1). The behaviour of this instruction is not defined if the
    index is outside this range. This instruction must be the rightmost
    instruction in its rung.


> PIECEWISE LINEAR TABLE    {yvar :=     }
                           -{ PWL[xvar]  }-

    This is a good way to approximate a complicated function or
    curve. It might, for example, be useful if you are trying to apply
    a calibration curve to convert a raw output voltage from a sensor
    into more convenient units.

    Assume that you are trying to approximate a function that converts
    an integer input variable, x, to an integer output variable, y. You
    know the function at several points; for example, you might know that

        f(0)   = 2
        f(5)   = 10
        f(10)  = 50
        f(100) = 100

    This means that the points

        (x0, y0)   = (  0,   2)
        (x1, y1)   = (  5,  10)
        (x2, y2)   = ( 10,  50)
        (x3, y3)   = (100, 100)

    lie on that curve. You can enter those 4 points into a table
    associated with the piecewise linear instruction. The piecewise linear
    instruction will look at the value of xvar, and set the value of
    yvar. It will set yvar in such a way that the piecewise linear curve
    will pass through all of the points that you give it; for example,
    if you set xvar = 10, then the instruction will set yvar = 50.

    If you give the instruction a value of xvar that lies between two
    of the values of x for which you have given it points, then the
    instruction will set yvar so that (xvar, yvar) lies on the straight
    line connecting those two points in the table.  For example, xvar =
    55 gives an output of yvar = 75. (The two points in the table are
    (10, 50) and (100, 100). 55 is half-way between 10 and 100, and 75
    is half-way between 50 and 100, so (55, 75) lies on the line that
    connects those two points.)

    The points must be specified in ascending order by x coordinate. It
    may not be possible to perform mathematical operations required for
    certain look-up tables using 16-bit integer math; if this is the
    case, then LDmicro will warn you. For example, this look up table
    will produce an error:

        (x0, y0)    = (  0,   0)
        (x1, y1)    = (300, 300)

    You can fix these errors by making the distance between points in
    the table smaller. For example, this table is equivalent to the one
    given above, and it does not produce an error:

        (x0, y0)    = (  0,   0)
        (x1, y1)    = (150, 150)
        (x2, y2)    = (300, 300)

    It should hardly ever be necessary to use more than five or six
    points. Adding more points makes your code larger and slower to
    execute. The behaviour if you pass a value of `xvar' greater than
    the greatest x coordinate in the table or less than the smallest x
    coordinate in the table is undefined. This instruction must be the
    rightmost instruction in its rung.


> A/D CONVERTER READ           Aname
                           --{READ ADC}--

    LDmicro can generate code to use the A/D converters built in to
    certain microcontrollers. If the input condition to this instruction
    is true, then a single sample from the A/D converter is acquired and
    stored in the variable `Aname'. This variable can subsequently be
    manipulated with general variable operations (less than, greater than,
    arithmetic, and so on). Assign a pin to the `Axxx' variable in the
    same way that you would assign a pin to a digital input or output,
    by double-clicking it in the list at the bottom of the screen. If
    the input condition to this rung is false then the variable `Aname'
    is left unchanged.

    For all currently-supported devices, 0 volts input corresponds to
    an ADC reading of 0, and an input equal to Vdd (the supply voltage)
    corresponds to an ADC reading of 1023. If you are using an AVR, then
    connect AREF to Vdd. You can use arithmetic operations to scale the
    reading to more convenient units afterwards, but remember that you
    are using integer math. In general not all pins will be available
    for use with the A/D converter. The software will not allow you to
    assign non-A/D pins to an analog input. This instruction must be
    the rightmost instruction in its rung.


> SET PWM DUTY CYCLE          duty_cycle
                           -{PWM 32.8 kHz}-

    LDmicro can generate code to use the PWM peripheral built in to
    certain microcontrollers. If the input condition to this instruction
    is true, then the duty cycle of the PWM peripheral is set to the
    value of the variable duty_cycle. The duty cycle must be a number
    between 0 and 100; 0 corresponds to always low, and 100 corresponds to
    always high. (If you are familiar with how the PWM peripheral works,
    then notice that that means that LDmicro automatically scales the
    duty cycle variable from percent to PWM clock periods.)

    You can specify the target PWM frequency, in Hz. The frequency that
    you specify might not be exactly achievable, depending on how it
    divides into the microcontroller's clock frequency. LDmicro will
    choose the closest achievable frequency; if the error is large then
    it will warn you. Faster speeds may sacrifice resolution.

    This instruction must be the rightmost instruction in its rung.
    The ladder logic runtime consumes one timer to measure the cycle
    time. That means that PWM is only available on microcontrollers
    with at least two suitable timers. PWM uses pin CCP2 (not CCP1)
    on PIC16 chips and OC2 (not OC1A) on AVRs.


> MAKE PERSISTENT            saved_var
                           --{PERSIST}--

    When the rung-in condition of this instruction is true, it causes the
    specified integer variable to be automatically saved to EEPROM. That
    means that its value will persist, even when the micro loses
    power. There is no need to explicitly save the variable to EEPROM;
    that will happen automatically, whenever the variable changes. The
    variable is automatically loaded from EEPROM after power-on reset. If
    a variable that changes frequently is made persistent, then the
    EEPROM in your micro may wear out very quickly, because it is only
    good for a limited (~100 000) number of writes. When the rung-in
    condition is false, nothing happens. This instruction must be the
    rightmost instruction in its rung.


> UART (SERIAL) RECEIVE          var
                           --{UART RECV}--

    LDmicro can generate code to use the UART built in to certain
    microcontrollers. On AVRs with multiple UARTs only UART1 (not
    UART0) is supported. Configure the baud rate using Settings -> MCU
    Parameters. Certain baud rates may not be achievable with certain
    crystal frequencies; LDmicro will warn you if this is the case.

    If the input condition to this instruction is false, then nothing
    happens. If the input condition is true then this instruction tries
    to receive a single character from the UART. If no character is read
    then the output condition is false. If a character is read then its
    ASCII value is stored in `var', and the output condition is true
    for a single PLC cycle.


> UART (SERIAL) SEND             var
                           --{UART SEND}--

    LDmicro can generate code to use the UARTs built in to certain
    microcontrollers. On AVRS with multiple UARTs only UART1 (not
    UART0) is supported. Configure the baud rate using Settings -> MCU
    Parameters. Certain baud rates may not be achievable with certain
    crystal frequencies; LDmicro will warn you if this is the case.

    If the input condition to this instruction is false, then nothing
    happens. If the input condition is true then this instruction writes
    a single character to the UART. The ASCII value of the character to
    send must previously have been stored in `var'. The output condition
    of the rung is true if the UART is busy (currently transmitting a
    character), and false otherwise.

    Remember that characters take some time to transmit. Check the output
    condition of this instruction to ensure that the first character has
    been transmitted before trying to send a second character, or use
    a timer to insert a delay between characters. You must only bring
    the input condition true (try to send a character) when the output
    condition is false (UART is not busy).

    Investigate the formatted string instruction (next) before using this
    instruction. The formatted string instruction is much easier to use,
    and it is almost certainly capable of doing what you want.


> FORMATTED STRING OVER UART                var
                                   -{"Pressure: \\3\\r\\n"}-

    LDmicro can generate code to use the UARTs built in to certain
    microcontrollers. On AVRS with multiple UARTs only UART1 (not
    UART0) is supported. Configure the baud rate using Settings -> MCU
    Parameters. Certain baud rates may not be achievable with certain
    crystal frequencies; LDmicro will warn you if this is the case.

    When the rung-in condition for this instruction goes from false to
    true, it starts to send an entire string over the serial port. If
    the string contains the special sequence `\\3', then that sequence
    will be replaced with the value of `var', which is automatically
    converted into a string. The variable will be formatted to take
    exactly 3 characters; for example, if `var' is equal to 35, then
    the exact string printed will be `Pressure:  35\\r\\n' (note the extra
    space). If instead `var' were equal to 1432, then the behaviour would
    be undefined, because 1432 has more than three digits. In that case
    it would be necessary to use `\\4' instead.

    If the variable might be negative, then use `\\-3d' (or `\\-4d'
    etc.) instead. That will cause LDmicro to print a leading space for
    positive numbers, and a leading minus sign for negative numbers.

    If multiple formatted string instructions are energized at once
    (or if one is energized before another completes), or if these
    instructions are intermixed with the UART TX instructions, then the
    behaviour is undefined.

    It is also possible to use this instruction to output a fixed string,
    without interpolating an integer variable's value into the text that
    is sent over serial. In that case simply do not include the special
    escape sequence.

    Use `\\\\' for a literal backslash. In addition to the escape sequence
    for interpolating an integer variable, the following control
    characters are available:
        * \\r   -- carriage return
        * \\n   -- newline
        * \\f   -- formfeed
        * \\b   -- backspace
        * \\xAB -- character with ASCII value 0xAB (hex)

    The rung-out condition of this instruction is true while it is
    transmitting data, else false. This instruction consumes a very
    large amount of program memory, so it should be used sparingly. The
    present implementation is not efficient, but a better one will
    require modifications to all the back-ends.


A NOTE ON USING MATH
====================

Remember that LDmicro performs only 16-bit integer math. That means
that the final result of any calculation that you perform must be an
integer between -32768 and 32767. It also mean that the intermediate
results of your calculation must all be within that range.

For example, let us say that you wanted to calculate y = (1/x)*1200,
where x is between 1 and 20. Then y goes between 1200 and 60, which
fits into a 16-bit integer, so it is at least in theory possible to
perform the calculation. There are two ways that you might code this:
you can perform the reciprocal, and then multiply:

   ||         {DIV  temp  :=}          ||
   ||---------{ 1 / x       }----------||
   ||                                  ||
   ||          {MUL  y  :=  }          ||
   ||----------{ temp * 1200}----------||
   ||                                  ||

Or you could just do the division directly, in a single step:

   ||           {DIV  y  :=}           ||
   ||-----------{ 1200 / x }-----------||

Mathematically, these two are equivalent; but if you try them, then you
will find that the first one gives an incorrect result of y = 0. That
is because the variable `temp' underflows. For example, when x = 3,
(1 / x) = 0.333, but that is not an integer; the division operation
approximates this as temp = 0. Then y = temp * 1200 = 0. In the second
case there is no intermediate result to underflow, so everything works.

If you are seeing problems with your math, then check intermediate
results for underflow (or overflow, which `wraps around'; for example,
32767 + 1 = -32768). When possible, choose units that put values in
a range of -100 to 100.

When you need to scale a variable by some factor, do it using a multiply
and a divide. For example, to scale y = 1.8*x, calculate y = (9/5)*x
(which is the same, since 1.8 = 9/5), and code this as y = (9*x)/5,
performing the multiplication first:

   ||         {MUL  temp  :=}          ||
   ||---------{ x * 9       }----------||
   ||                                  ||
   ||           {DIV  y  :=}           ||
   ||-----------{ temp / 5 }-----------||

This works for all x < (32767 / 9), or x < 3640. For larger values of x,
the variable `temp' would overflow. There is a similar lower limit on x.


CODING STYLE
============

I allow multiple coils in parallel in a single rung. This means that
you can do things like this:

   ||       Xa               Ya        ||
 1 ||-------] [--------------( )-------||
   ||                                  ||
   ||       Xb               Yb        ||
   ||-------] [------+-------( )-------||
   ||                |                 ||
   ||                |       Yc        ||
   ||                +-------( )-------||
   ||                                  ||

Instead of this:

   ||       Xa               Ya        ||
 1 ||-------] [--------------( )-------||
   ||                                  ||
   ||                                  ||
   ||                                  ||
   ||                                  ||
   ||       Xb               Yb        ||
 2 ||-------] [--------------( )-------||
   ||                                  ||
   ||                                  ||
   ||                                  ||
   ||                                  ||
   ||       Xb               Yc        ||
 3 ||-------] [--------------( )-------||
   ||                                  ||

This means that in theory you could write any program as one giant rung,
and there is no need to use multiple rungs at all. In practice that
would be a bad idea, because as rungs become more complex they become
more difficult to edit without deleting and redrawing a lot of logic.

Still, it is often a good idea to group related logic together as a single
rung. This generates nearly identical code to if you made separate rungs,
but it shows that they are related when you look at them on the ladder
diagram.

                  *                 *                  *

In general, it is considered poor form to write code in such a way that
its output depends on the order of the rungs. For example, this code
isn't very good if both Xa and Xb might ever be true:

   ||       Xa         {v  :=       }  ||
 1 ||-------] [--------{ 12      MOV}--||
   ||                                  ||
   ||       Xb         {v  :=       }  ||
   ||-------] [--------{ 23      MOV}--||
   ||                                  ||
   ||                                  ||
   ||                                  ||
   ||                                  ||
   ||      [v >]             Yc        ||
 2 ||------[ 15]-------------( )-------||
   ||                                  ||

I will break this rule if in doing so I can make a piece of code
significantly more compact, though. For example, here is how I would
convert a 4-bit binary quantity on Xb3:0 into an integer:

   ||                                   {v  :=       }  ||
 3 ||-----------------------------------{ 0       MOV}--||
   ||                                                   ||
   ||       Xb0                  {ADD  v  :=}           ||
   ||-------] [------------------{ v + 1    }-----------||
   ||                                                   ||
   ||       Xb1                  {ADD  v  :=}           ||
   ||-------] [------------------{ v + 2    }-----------||
   ||                                                   ||
   ||       Xb2                  {ADD  v  :=}           ||
   ||-------] [------------------{ v + 4    }-----------||
   ||                                                   ||
   ||       Xb3                  {ADD  v  :=}           ||
   ||-------] [------------------{ v + 8    }-----------||
   ||                                                   ||

If the MOV statement were moved to the bottom of the rung instead of the
top, then the value of v when it is read elsewhere in the program would
be 0. The output of this code therefore depends on the order in which
the instructions are evaluated. Considering how cumbersome it would be
to code this any other way, I accept that.


BUGS
====

LDmicro does not generate very efficient code; it is slow to execute, and
wasteful of flash and RAM. In spite of this, a mid-sized PIC or AVR can
do everything that a small PLC can, so this does not bother me very much.

The maximum length of variable names is highly limited. This is so that
they fit nicely onto the ladder diagram, so I don't see a good solution
to that.

If your program is too big for the time, program memory, or data memory
constraints of the device that you have chosen then you probably won't
get an error. It will just screw up somewhere.

Careless programming in the file load/save routines probably makes it
possible to crash or execute arbitrary code given a corrupt or malicious
.ld file.

Please report additional bugs or feature requests to the author.

Thanks to:
    * Marcelo Solano, for reporting a UI bug under Win98
    * Serge V. Polubarjev, for not only noticing that RA3:0 on the
      PIC16F628 didn't work but also telling me how to fix it
    * Maxim Ibragimov, for reporting and diagnosing major problems
      with the till-then-untested ATmega16 and ATmega162 targets
    * Bill Kishonti, for reporting that the simulator crashed when the
      ladder logic program divided by zero
    * Mohamed Tayae, for reporting that persistent variables were broken
      on the PIC16F628
    * David Rothwell, for reporting several user interface bugs and a
      problem with the "Export as Text" function


COPYING, AND DISCLAIMER
=======================

DO NOT USE CODE GENERATED BY LDMICRO IN APPLICATIONS WHERE SOFTWARE
FAILURE COULD RESULT IN DANGER TO HUMAN LIFE OR DAMAGE TO PROPERTY. THE
AUTHOR ASSUMES NO LIABILITY FOR ANY DAMAGES RESULTING FROM THE OPERATION
OF LDMICRO OR CODE GENERATED BY LDMICRO.

This program is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation, either version 3 of the License, or (at your
option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with this program. If not, see <http://www.gnu.org/licenses/>.


Jonathan Westhues

Rijswijk      -- Dec 2004
Waterloo ON   -- Jun, Jul 2005
Cambridge MA  -- Sep, Dec 2005
                 Feb, Mar 2006
                 Feb 2007
Seattle WA    -- Feb 2009

Email: user jwesthues, at host cq.cx


